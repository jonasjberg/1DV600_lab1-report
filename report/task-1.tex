% ______________________________________________________________________________
%
%   1DV600 - Software Technology
%   Assignment 1 -- "Personal planning, Vision and Project Plan"
%
%  Author:  Jonas Sj√∂berg
%           Linnaeus University
%           js224eh@student.lnu.se
%           https://github.com/jonasjberg
%
%    Date:  2017-02-01 -- 2017-02-05
%
% License:  Creative Commons Attribution 4.0 International (CC BY 4.0)
%           <http://creativecommons.org/licenses/by/4.0/legalcode>
%           See LICENSE.md for additional licensing information.
% ______________________________________________________________________________


% ______________________________________________________________________________
\section{Task 1 -- Personal Planning}
% \subsection{Instructions}\label{task-1-instructions}
Instructions quoted as-is from the course Wiki \cite{1dv600:lab1:instructions}:

\begin{quote}
  When the client requests a list of books to present for the user it does the
  call \texttt{http://localhost:9090/api/books/} to the server and it expects
  the answer as a JSON object (an associative array). We are going to split the
  functionality into three tasks, but it is your task to plan these tasks. Take
  into account the time for learning and understanding of the problem when you
  plan the time. Make your planning with 15 minutes as the minimum unit. Repeat
  the following pattern for all subtasks (A, B, C):
  
  \begin{itemize}
    \item Plan
    \item Implement
    \item Reflect
  \end{itemize}
  
  Each subtask should be documented with at least 100 words.
\end{quote}


% ______________________________________________________________________________
\section{Subtask A -- Books}\label{task-1a}
% \subsection{Instructions}\label{task-1a-instructions}
Instructions quoted as-is from the course Wiki \cite{1dv600:lab1:instructions}:

\begin{quote}
  The main objective of the subtask is to create a list of books and a function
  or method to get them. There are slight differences depending on which
  implementation you are using, either Java or Node.js but those differences
  will be clearly noted. Common for both is that they should handle books,
  and for each book we need the information id, title, author, genre, publish
  date, price and description.

  \subparagraph{Java}
  Create a class in the package ``models'' that represents a book. After
  that, create a short list of fictive (or real) objects in the function
  getBooks that is available in GetBooksResource. When calling the URL
  http://localhost:9090/api/books the list of books should be outputted
  with System.out.println. The subtask is done when you see the objects in
  the terminal (where vagrant is run).
\end{quote}


\subsection{Plan}\label{task-1a-plan}
The \texttt{book} class is a critical datatype that will be used throughout the
software. As such, it would probably be wise to design the class in a way as 
to make it flexible and open for future modifications, as stated by the well known
``open/closed principle'' \cite{SOLID:OCP}, briefly stated \cite{SOLID:OCP:Meyer}:

\begin{quote}
  software entities (classes, modules, functions, etc.) should be open for
  extension, but closed for modification
\end{quote}


The class \texttt{book} should meet the following requirements:

\begin{itemize}
  \item Store information needed to describe books handled by the system.
        We are to include the following set of attributes:

  \begin{itemize}
    \item Id
    \item Title
    \item Author
    \item genre
    \item Date of publication
    \item Price
    \item Description
  \end{itemize}

  \item Provide suitable interfaces for accessing and possibly modifying the 
        data encapsulated in the class.
\end{itemize}

The initial plan is to implement a basic class with traditional mutators for
accessing private fields. This first implementation will use primitive data
types for its fields, which often means future expansion and modifications will
require refactoring. 

This design opposes the previously mentioned ``open/closed principle'', but
future refactoring seems a reasonable tradeoff in order to get a prototype
working as soon as possible.

This implementation should use the least amount of code possible to meet the
requirements.

% TODO: Finish this section
% We will have to refactor the code at some point in the future.

% Wrapper data types would be better


\subsection{Implement}\label{task-1a-implement}
The class was implemented in less than 10 minutes. What followed was
investigating bugs in the underlying framework ``dropwizard''
\cite{framework:dropwizard}.  The problems seems to be caused by printing a
combination of newlines and other characters to ``stdout'', which is hooked by
either ``dropwizard'' or the build system ``gradle'' \cite{tool:gradle}, in
order to add additinal information and timestamps to the message.


\subsection{Reflect}\label{task-1a-reflect}
This simple implementation matches the criteria which seems vague at this point,
the \texttt{book} class presents its state in JSON-format, and so deciding on
how the internal data types and overall program structure, including how
the different parts communicate, becomes very difficult.
I know for a fact that this simple implementation will need serious rework 
in order to be extended. But making the design more involved and modular
at this stage, with no information to go on, could possibly be a waste of time.

This kind of tradeoff seems to reoccur and turn up in various forms. The tradeoff
is that between 

\begin{description}
  \item [A] Try to predict future usage and development, design for maximum 
        flexibility and modularity. Means more initial work is needed to reach
        a minimum working state, but can pay off in the long run, the design
        makes modification and extension easier.  The risk is that the extra
        functionality and complexity might go complete unused, and the whole
        enterprise is thus a complete waste of time.
  \item [B] Assume very little about future developments, use the simplest 
        possible design that meets the requirements. Accept that the simple 
        solution is more rigid and sensitive to changes --- future changes in 
        requirements or functionality will require major refactoring.
\end{description}

% \begin{enumerate*}[label={\alph*)},font={\color{red!50!black}\bfseries}]
% \item bananas
% \item apples
% \item oranges and
% \item lemons.
% \end{enumerate*}

between more initial work on features that might not even
be useful in the future, but allowing for easier future expansion, versus less
initial work which meets the current requirements but compounds additinal work
over time due to a simple architecture that is more rigid and sensitive to
changes in the system.


% ______________________________________________________________________________
\section{Subtask B -- JSON}\label{subtask-b-json}
% \subsection{Instructions}\label{task-1b-instructions}
Instructions quoted as-is from the course Wiki \cite{1dv600:lab1:instructions}:

\begin{quote}
  Convert the objects created in subtask a into an JSON object and show it in
  the terminal using either System.out.println(Java) or console.log (Node.js).
  
  \subparagraph{Improvement Strategies}
  
  Choose two improvement strategies based on your reflections on subtask a and
  b. Describe what you have decided to improve and why. Implement your 
  improvements in the next subtask.
\end{quote}

\subsection{Plan}\label{task-1b-plan}
As with the first subtask, the plan is to use the simplest possible solution
that meets the requirements.
The first implementation will use simple, error-prone and crude raw string
manipulations to construct JSON-data.
If this method performs as expected when integrated into the rest of the system,
methods for converting from Java objects to JSON-data could be refactored into
a separate utility package.

\subsection{Implement}\label{task-1b-implement}
The code was written in less than 5 minutes. The basic method for
constructing the strings was re-used from the previous subtask.

The method that returns the JSON data, ``toJSON'' is shown in Listing~\ref{listing:tojson1}.

\javasource{include/tojson1.java}
           {Initial implementation of the \texttt{toJSON\(\)} method in the
            \texttt{Book} class.}
           {listing:tojson1}



\subsection{Reflect}\label{task-1b-reflect}
This should really be solved using the standard libraries native functions for
handling JSON. 
At the very least, these methods should be extracted and refactored into
utility functions stored in a separate package with other similar ``utility''
code.  This enables re-use across the entire project. Many companies re-use
utility code across many if not all projects.


\subsubsection{Improvement Strategies}
Based on the reflections on Subtask A \ref{task-1a-reflect} and Subtask B
\ref{task-1b-reflect}, I have chosen the two following improvements:

\begin{itemize}
  \item Improve JSON handling by leveraging the Java libraries.
  \item Modify how the book class is constructed.
        % TODO: Sure about that?
\end{itemize}





% ______________________________________________________________________________
\section{Subtask C -- Web}\label{subtask-c-web}
\subsection{Instructions}\label{task-1-instructions}
Instructions quoted as-is from the course Wiki \cite{1dv600:lab1:instructions}:

\begin{quote}
  In this subtask you are to answer the request in the web browser instead of
  printing it to the terminal. The subtask is done when you see the JSON object
  on screen. For inspiration, have a look at PingResource that you find in the
  same folder as the GetBooksResource. 

  If you follow the 
  \href{https://htmlpreview.github.io/?https://github.com/tobias-dv-lnu/1dv600-lab/blob/master/api-specification/api-specification.html}{API for the model}
  (as seen in 
  \href{https://htmlpreview.github.io/?https://github.com/tobias-dv-lnu/1dv600-lab/blob/master/api-specification/api-specification.html\#books-get}{GET api/books})
  , you will be able to show the books in the list.
\end{quote}


\subsection{Plan}\label{task-1c-plan}
As per the instructions, the plan is to look for the existing code to hints
on how to meet the requested functionality.

\subsection{Implement}\label{task-1c-implement}
The implementation was done as part of experimeting with the previous two
subtasks and the strange behaviour that the framework ``dropwizard'' exhibited
when new-lines was passed to the terminal.

\subsection{Reflect}\label{task-1c-reflect}
% TODO: Finish this section ..
